!***************************************************************************************************
!- PURPORSE:
!     ENTRY POINT OF READING DISPLACEMENT BOUNDARY CONDITION.
!  
!- INPUT ARGUMENTS:
!  NONE
!
!- OUTPUT ARGUMENTS:
!  NONE
!
!- CALL PROCEDURES:
!  MODULE PROCEDURE:   GET_MACRO, ERROR
!  EXTERNAL PROCEDURE: READ_DISPLACEMENT
!
!- CALLED BY
!  SOLVER_MANAGER
!
!- PROGAMMED BY:
!  ZHIHAI XIANG, DEPARTMENT OF ENGINEERING MECHANICS, TSINGHUA UNIVERSITY, JANUARY 17, 2016
!***************************************************************************************************

SUBROUTINE BOUNDARY_DISPLACEMENT

USE SOLUTION_DATA, ONLY: INT_KIND, WORD_KIND, LINE_KIND, BOUNDARY, GET_MACRO, ERROR, NUM_GIVEN_DISP,&
                         GIVEN_DISP

IMPLICIT NONE

CHARACTER(LINE_KIND) COMMAND
CHARACTER(WORD_KIND) ITEM    ! A TEMPERARY VARIABLE TO STORE STRINGS
INTEGER(INT_KIND)    NUMBER  ! A TEMPERARY VARIABLE TO STORE INTEGER NUMBERS
INTEGER(INT_KIND)    ERR     ! ERROR INDEX

!-- READ DISPLACEMENT BONDARY CONDITION 
DO
   COMMAND = GET_MACRO(BOUNDARY)
   
   IF(TRIM(COMMAND) .EQ. 'END DISPLACEMENT') EXIT
   
   READ(COMMAND,*) ITEM, NUMBER
   IF(NUMBER .LE. 0) CALL ERROR('The number of displacement nodes should be greater than 0!')
   
   SELECT CASE(TRIM(ITEM))
      CASE ('GIVEN_DISP')
         NUM_GIVEN_DISP = NUMBER
         IF(.NOT. ALLOCATED(GIVEN_DISP)) THEN
            ALLOCATE(GIVEN_DISP(NUMBER), STAT = ERR)
            IF(ERR .NE. 0) CALL ERROR('Fail to allocate GIVEN_DISP!')
         ENDIF
         
         CALL READ_DISPLACEMENT('GIVEN_DISP', NUM_GIVEN_DISP, GIVEN_DISP)
   
      CASE DEFAULT
         CALL ERROR('Invalid displacement type: ' // TRIM(COMMAND))
   END SELECT
ENDDO

END SUBROUTINE BOUNDARY_DISPLACEMENT