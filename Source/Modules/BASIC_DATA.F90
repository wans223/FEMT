!***************************************************************************************************
!- PURPORSE:
!  DEFINES BASIC DATA TYPES AND PROCEDURES
!
!- CONSTANTS
!  INT_KIND, REAL_KIND, LG_KIND, WORD_KIND, LINE_KIND, REAL_EPS, NUM_ELE_TYPE, NUM_OPT, 
!  GAUSS_COORD1, GAUSS_COORD2, GAUSS_COORD3, GAUSS_WEIGHT1, GAUSS_WEIGHT2, GAUSS_WEIGHT3
!
!- TYPES
!  MATERIAL, GEOMETRY, NUM_INTE, ELEMENT, ELE_PROP
!
!- GLOABLE VARIABLES:
!  PROJECT_NAME, NUM_NODE, NUM_MATERIAL, NUM_GEOMETRY, NUM_ELEMENT, XYZ, MATERIALS, GEOMETRIES,
!  ELEMENTS, ELEMENT_LIB
!  
!- FILE HANDLES:
!  CONTROL, BOUNDARY, LOG, OUT, ELE_STIFF, G_STIFF
!
!- MODULE PROCEDURES:
!  * PUBLIC : .EQ., NUM2STR, REMOVE_FIRSTWORD, GET_MACRO, ERROR
!  * PRIVATE: ELEMENT_EQ, REMOVE_BLANK_TABLE, INT_TO_STRING, REAL_TO_STRING
!
!- PROGAMMED BY:
!  ZHIHAI XIANG, DEPARTMENT OF ENGINEERING MECHANICS, TSINGHUA UNIVERSITY, NOVEMBER 1, 2015
!***************************************************************************************************

MODULE BASIC_DATA

IMPLICIT NONE

!-- GLOBLE CONSTANTS --
INTEGER(4), PARAMETER::        INT_KIND     = SELECTED_INT_KIND(8)
INTEGER(4), PARAMETER::        REAL_KIND    = SELECTED_REAL_KIND(P=15)
INTEGER(4), PARAMETER::        LG_KIND      = 4
INTEGER(4), PARAMETER::        WORD_KIND    = 32
INTEGER(4), PARAMETER::        LINE_KIND    = 128
REAL(REAL_KIND), PARAMETER::   REAL_EPS     = EPSILON(1.0_REAL_KIND)    ! THE MINIMUM DIFFERENCE BETWEEN TWO REAL NUMBERS
INTEGER(INT_KIND), PARAMETER:: NUM_ELE_TYPE = 5                         ! THE TOTAL NUMBER OF ELEMENT TYPES
INTEGER(INT_KIND), PARAMETER:: NUM_OPT = 6                              ! THE NUMBER OF COMMAND OPTIONS
! THE NATURAL GAUSS COORDINATE
REAL(REAL_KIND), PARAMETER:: GAUSS_COORD1    = 0.0_REAL_KIND
REAL(REAL_KIND), PARAMETER:: GAUSS_COORD2(2) = (/1.0_REAL_KIND / SQRT(3.0_REAL_KIND), -1.0_REAL_KIND / SQRT(3.0_REAL_KIND)/)
REAL(REAL_KIND), PARAMETER:: GAUSS_COORD3(3) = (/SQRT(0.6_REAL_KIND), 0.0_REAL_KIND, -SQRT(0.6_REAL_KIND)/)
! THE WEIGHT AT GAUSS POINT
REAL(REAL_KIND), PARAMETER:: GAUSS_WEIGHT1    = 2.0_REAL_KIND
REAL(REAL_KIND), PARAMETER:: GAUSS_WEIGHT2(2) = (/1.0_REAL_KIND, 1.0_REAL_KIND/)
REAL(REAL_KIND), PARAMETER:: GAUSS_WEIGHT3(3) = (/5.0_REAL_KIND / 9.0_REAL_KIND, &
                                                  8.0_REAL_KIND / 9.0_REAL_KIND, &
                                                  5.0_REAL_KIND / 9.0_REAL_KIND/)                   


!-- BASIC STRUCTURES --
! THE STRUCTURE TO STORE THE MATERIAL PROPERTIES
TYPE MATERIAL
   CHARACTER(WORD_KIND):: MATERIAL_TYPE = ' '
   
   ! MECHANICAL PROPERTIES
   ! ISOTROPIC MATERIAL
   REAL(REAL_KIND) E             ! YOUNG'S MODULUS 'E' FOR ISOTROPIC MATERIAL
   REAL(REAL_KIND) V             ! POISSON'S RATIO 'V' FOR ISOTROPIC MATERIAL
END TYPE

! GEOMETRICAL PROPERTIES
TYPE GEOMETRY
   CHARACTER(WORD_KIND):: GEOMETRY_TYPE = ' '
      
   REAL(REAL_KIND) THICKNESS     ! THE THICKNESSES OF A PLANE ELEMENT
END TYPE

! NUMERICAL INTEGRATION DATA
TYPE NUM_INTE
   REAL(REAL_KIND) COORD(3)      ! THE LOCAL COORDINATE OF THIS GAUSS POINT
   REAL(REAL_KIND) WEIGHT        ! THE GAUSS INTEGERATION WEIGHT
END TYPE

! THE INFORMATION OF A KIND OF ELEMENT
TYPE ELEMENT
   CHARACTER(WORD_KIND)           ELEMENT_TYPE
   INTEGER(INT_KIND)              NUM_NODE      ! THE NUMBER OF NODES IN THIS ELEMENT
   INTEGER(INT_KIND)              NUM_STIFF     ! THE NUMBER OF TERMS IN UPPER HALF OF STIFFNESS MATRIX
   INTEGER(INT_KIND)              DISP_DOF      ! THE DEGREES OF DISPLACEMENT FREEDOM AT EACH NODE
   INTEGER(INT_KIND)              NUM_INTP      ! THE NUMBER OF INTEGRATION POINTS
   TYPE(NUM_INTE), ALLOCATABLE::  INTE_COORD(:) ! THE COORDINATE OF INTEGRATION POINTS
   REAL(REAL_KIND), ALLOCATABLE:: SHAPE(:,:)    ! SHAPE FUNCTION AT INTEGRATION POINTS
   REAL(REAL_KIND), ALLOCATABLE:: DSHAPE(:,:,:) ! THE DERIVATIVE OF SHAPE FUNCTION OVER NATURAL COORDINATES AT INTEGRATION POINTS
END TYPE

! ELEMENT PROPERTIES
TYPE ELE_PROP
   INTEGER(INT_KIND)                MATERIAL    ! THE MATERIAL TYPE NUMBER
   INTEGER(INT_KIND)                GEOMETRY    ! THE GEOMETRY TYPE NUMBER
   INTEGER(INT_KIND)                ELEMENT     ! THE ELEMENT TYPE NUMBER
   INTEGER(INT_KIND), ALLOCATABLE:: NODE(:)     ! THE LIST OF NODE NUMBER
END TYPE

!-- GLOBLE VARIABLES --
! BASIC INFORMATION
CHARACTER(WORD_KIND) PROJECT_NAME
INTEGER(INT_KIND)    NUM_NODE                   ! THE TOTAL NUMBER OF NODES
INTEGER(INT_KIND)    NUM_MATERIAL               ! THE TOTAL NUMBER OF MATERIALS
INTEGER(INT_KIND)    NUM_GEOMETRY               ! THE TOTAL NUMBER OF GEOMETRIES
INTEGER(INT_KIND)    NUM_ELEMENT                ! THE TOTAL NUMBER OF ELEMENTS

REAL(REAL_KIND), ALLOCATABLE:: XYZ(:,:)         ! NODE GLOBAL COORDINATES
TYPE(MATERIAL), ALLOCATABLE::  MATERIALS(:)     ! MATERIAL INFORMATION
TYPE(GEOMETRY), ALLOCATABLE::  GEOMETRIES(:)    ! GEOMETRY INFORMATION
TYPE(ELE_PROP), ALLOCATABLE::  ELEMENTS(:)      ! ELEMENT INFORMATION
TYPE(ELEMENT), TARGET:: ELEMENT_LIB(NUM_ELE_TYPE)  ! THE INFORMATION OF ELEMENT TYPES

!-- FILE HANDLES --
INTEGER(INT_KIND), PARAMETER:: CONTROL   = 1    ! BASIC INFORMATION AND CONTRAL MACROES
INTEGER(INT_KIND), PARAMETER:: BOUNDARY  = 2    ! BOUNDARY CONDITIONS FOR EACH LOAD CASE
INTEGER(INT_KIND), PARAMETER:: LOG       = 3    ! LOG FILE
INTEGER(INT_KIND), PARAMETER:: OUT       = 4    ! OUTPUT FILE
INTEGER(INT_KIND), PARAMETER:: ELE_STIFF = 5    ! ELEMENT STIFFNESS MATRIX
                                                  ! UNIT 6 IS RESERVED FOR ERROR INFORMATION OF SOLVER
INTEGER(INT_KIND), PARAMETER:: G_STIFF   = 7    ! GLOBAL STIFFNESS

!-- INTERFACES --
! DEFINE NEW OPERATOR FOR COMPARING
INTERFACE OPERATOR (.EQ.)
   MODULE PROCEDURE ELEMENT_EQ      ! COMPARE TWO ELEMENTS
END INTERFACE

! CONVERT NUMBER TO STRING
INTERFACE NUM2STR
   MODULE PROCEDURE INT_TO_STRING
   MODULE PROCEDURE REAL_TO_STRING
END INTERFACE

PRIVATE ELEMENT_EQ, REMOVE_BLANK_TABLE, INT_TO_STRING, REAL_TO_STRING

CONTAINS
   !------------------------------------------------------------------------------------------------  
   ! CHECK IF THE TWO ELEMENTS ARE THE SAME
   !------------------------------------------------------------------------------------------------  
   PURE FUNCTION ELEMENT_EQ(E1, E2)
   
   IMPLICIT NONE
   
   TYPE(ELE_PROP), INTENT(IN):: E1
   TYPE(ELE_PROP), INTENT(IN):: E2
   LOGICAL(LG_KIND)             ELEMENT_EQ
   
   ELEMENT_EQ = E1%ELEMENT    .EQ. E2%ELEMENT  .AND. &
                E1%MATERIAL   .EQ. E2%MATERIAL .AND. &
                SIZE(E1%NODE) .EQ. SIZE(E2%NODE)
                
   IF(ELEMENT_EQ) ELEMENT_EQ = ELEMENT_EQ .AND. ALL(E1%NODE .EQ. E2%NODE)

   END FUNCTION
      
   !------------------------------------------------------------------------------------------------
   ! DELETE LEADING BLANKS AND TABLES IN A STRING
   !------------------------------------------------------------------------------------------------
   FUNCTION REMOVE_BLANK_TABLE(STRING)
   
   IMPLICIT NONE
   
   CHARACTER(*), INTENT(IN):: STRING
   CHARACTER(LINE_KIND)       REMOVE_BLANK_TABLE   ! THE NET STRING
   INTEGER(INT_KIND)          POS                  ! POSITION INDEX

   !-- REPLACE TABLES WITH BLANKS --
   REMOVE_BLANK_TABLE = STRING

   DO POS = 1, LEN(REMOVE_BLANK_TABLE)
      IF(ICHAR(REMOVE_BLANK_TABLE(POS:POS)) .EQ. 9) REMOVE_BLANK_TABLE(POS:POS) = ' '
   ENDDO
   
   !-- REMOVE LEADING BLANKS --
   REMOVE_BLANK_TABLE = ADJUSTL(REMOVE_BLANK_TABLE)
   
   END FUNCTION
   
   !------------------------------------------------------------------------------------------------
   ! REMOVE THE FIRST WORD IN A STRING
   !------------------------------------------------------------------------------------------------
   FUNCTION REMOVE_FIRSTWORD(STRING)
   
   IMPLICIT NONE
   
   CHARACTER(*), INTENT(IN):: STRING
   CHARACTER(LINE_KIND)       REMOVE_FIRSTWORD
   INTEGER(INT_KIND)          BLANK
   INTEGER(INT_KIND)          TABLE
   
   !-- REMOVE THE LEADING BLANKS AND TABLES --
   REMOVE_FIRSTWORD = REMOVE_BLANK_TABLE(STRING)
   
   !-- CHECK INLINE COMMENTS --
   IF(REMOVE_FIRSTWORD(1:1) .EQ. '!') THEN
      REMOVE_FIRSTWORD = ' '
      RETURN
   ENDIF
   
   !-- GET THE POSITION OF THE FIRST BLANK --
   BLANK = INDEX(REMOVE_FIRSTWORD, ' ')
   
   !-- GET THE POSITION OF THE FIRST TABLE --
   TABLE = INDEX(REMOVE_FIRSTWORD, CHAR(9))
   
   !-- REPLACE THE FIRST WORD WITH BLANKS --
   IF(BLANK .EQ. 0) BLANK = LEN(REMOVE_FIRSTWORD)
   IF(TABLE .EQ. 0) TABLE = LEN(REMOVE_FIRSTWORD)
   REMOVE_FIRSTWORD(1:MIN(BLANK, TABLE)) = ' '
   
   !-- REMOVE THE LEADING BLANKS --
   REMOVE_FIRSTWORD = ADJUSTL(REMOVE_FIRSTWORD)
      
   END FUNCTION
   
   !------------------------------------------------------------------------------------------------
   ! REMOVE THE FIRST WORD IN A STRING
   !------------------------------------------------------------------------------------------------
   FUNCTION REMOVE_FIRSTWORD2(STRING)
   
   IMPLICIT NONE
   
   CHARACTER(*), INTENT(IN):: STRING
   CHARACTER(LINE_KIND)       REMOVE_FIRSTWORD,REMOVE_FIRSTWORD2
   INTEGER(INT_KIND)          BLANK
   INTEGER(INT_KIND)          TABLE
   INTEGER(INT_KIND)          COMMA
   
   !-- REMOVE THE LEADING BLANKS AND TABLES --
   REMOVE_FIRSTWORD = REMOVE_BLANK_TABLE(STRING)
   
   !-- CHECK INLINE COMMENTS --
   IF(REMOVE_FIRSTWORD(1:1) .EQ. '!') THEN
      REMOVE_FIRSTWORD = ' '
      RETURN
   ENDIF
   
   !-- GET THE POSITION OF THE FIRST BLANK --
   BLANK = INDEX(REMOVE_FIRSTWORD, ' ')
   
   !-- GET THE POSITION OF THE FIRST TABLE --
   TABLE = INDEX(REMOVE_FIRSTWORD, CHAR(9))
   
   !-- GET THE POSITION OF THE FIRST BLANK --
   COMMA = INDEX(REMOVE_FIRSTWORD, ',')
   
   !-- REPLACE THE FIRST WORD WITH BLANKS --
   IF(BLANK .EQ. 0) BLANK = LEN(REMOVE_FIRSTWORD)
   IF(TABLE .EQ. 0) TABLE = LEN(REMOVE_FIRSTWORD)
   IF(COMMA .EQ. 0) COMMA = LEN(REMOVE_FIRSTWORD)

   REMOVE_FIRSTWORD(1:MIN(BLANK, TABLE,COMMA)) = ' '
   
   !-- REMOVE THE LEADING BLANKS --
   REMOVE_FIRSTWORD2 = ADJUSTL(REMOVE_FIRSTWORD)
      
   END FUNCTION
   
   !------------------------------------------------------------------------------------------------
   ! READ A LINE FROM A FILE
   !------------------------------------------------------------------------------------------------
   CHARACTER(LINE_KIND) FUNCTION GET_MACRO(FILE)
   
   IMPLICIT NONE
   
   INTEGER(INT_KIND), INTENT(IN):: FILE
   INTEGER(INT_KIND)               I      ! A LOOP INDEX

   !-- BYPASS LEADING '!' AND BLANK LINE --
   DO
      READ(FILE, '(A<LINE_KIND>)') GET_MACRO
      
      ! DELETE LEADING BLANKS AND TABLES
      GET_MACRO = REMOVE_BLANK_TABLE(GET_MACRO)     
                    
      IF(GET_MACRO(1:1) .NE. '!' .AND. GET_MACRO(1:1) .NE. ' ') EXIT
   END DO
   
   !-- BYPASS WORDS AFTER '!'
   DO I = 1, LINE_KIND
      IF(GET_MACRO(I:I) .EQ. '!') THEN
         GET_MACRO(I:LINE_KIND) = ' '
         EXIT
      ENDIF
   ENDDO
   
   !-- CONVERT TO UPPER CASE --
   FORALL(I = 1:LEN_TRIM(GET_MACRO), GET_MACRO(I:I) .GE. 'a' .AND. GET_MACRO(I:I) .LE. 'z') &
      GET_MACRO(I:I) = CHAR(ICHAR(GET_MACRO(I:I)) - 32)
   
   END FUNCTION
     
   !------------------------------------------------------------------------------------------------
   ! CONVERT INTEGER TO STRING
   !------------------------------------------------------------------------------------------------
   CHARACTER(WORD_KIND) FUNCTION INT_TO_STRING(VALUE, FMT)
   
   IMPLICIT NONE
   
   INTEGER(INT_KIND), INTENT(IN)::      VALUE         
   CHARACTER(*), OPTIONAL, INTENT(IN):: FMT     ! FORMAT LIST
   
   IF(PRESENT(FMT)) THEN
      WRITE(INT_TO_STRING, FMT) VALUE
   ELSE
      WRITE(INT_TO_STRING,*) VALUE
   ENDIF
   
   END FUNCTION
   
   !------------------------------------------------------------------------------------------------
   ! CONVERT REAL TO STRING
   !------------------------------------------------------------------------------------------------
   CHARACTER(WORD_KIND) FUNCTION REAL_TO_STRING(VALUE, FMT)
   
   IMPLICIT NONE
   
   REAL(REAL_KIND), INTENT(IN)::        VALUE
   CHARACTER(*), OPTIONAL, INTENT(IN):: FMT     ! FORMAT LIST
   
   IF(PRESENT(FMT)) THEN
      WRITE(REAL_TO_STRING, FMT) VALUE
   ELSE
      WRITE(REAL_TO_STRING,*) VALUE
   ENDIF
   
   END FUNCTION
      
   !------------------------------------------------------------------------------------------------
   ! PROMPT ERROR FUNCTION THEN STOP THE WHOLE PROGRAM
   !------------------------------------------------------------------------------------------------
   SUBROUTINE ERROR(MESSAGE)
   
   IMPLICIT NONE
   
   CHARACTER(*), INTENT(IN):: MESSAGE
   LOGICAL(LG_KIND)           EXISTED
   
   INQUIRE(FILE = TRIM(PROJECT_NAME) // '.LOG', EXIST = EXISTED)
   IF(EXISTED) WRITE(LOG,*) MESSAGE
   
   PRINT *, MESSAGE
   STOP
   
   END SUBROUTINE

END MODULE